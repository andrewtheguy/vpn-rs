# tunnel-rs-vpn server configuration example
#
# Usage: tunnel-rs-vpn server -c vpn_server.toml
#        tunnel-rs-vpn server --default-config
#
# CLI arguments take precedence over config file values.

# Required: validates config matches CLI command
role = "vpnserver"
mode = "iroh"

[iroh]
# ============================================================================
# VPN Network Configuration
# ============================================================================
# At least one of 'network' (IPv4) or 'network6' (IPv6) is REQUIRED.
# You can configure:
#   - IPv4-only:   Set 'network' only
#   - IPv6-only:   Set 'network6' only
#   - Dual-stack:  Set both 'network' and 'network6'

# IPv4 VPN network CIDR (optional if network6 is set)
# Clients will be assigned IPs from this network
network = "10.0.0.0/24"

# Server's VPN IP address (optional, defaults to first IP in network)
# This becomes the gateway for connected clients
# server_ip = "10.0.0.1"

# ============================================================================
# IPv6 Configuration (Optional for Dual-Stack or IPv6-only)
# ============================================================================
# Enable IPv6 alongside IPv4 (dual-stack) or as the only address family (IPv6-only).
# When both network and network6 are set, clients receive addresses from both.

# IPv6 VPN network CIDR (required for dual-stack or IPv6-only)
# Clients will be assigned IPs from this network (one /128 per client)
# network6 = "fd00::/64"

# Server's IPv6 VPN address (optional, defaults to first IP in network6)
# This becomes the IPv6 gateway for connected clients
# server_ip6 = "fd00::1"

# ============================================================================
# IPv6-only Example Configuration
# ============================================================================
# For an IPv6-only VPN server, comment out 'network' above and enable:
#
# # network = "10.0.0.0/24"  # Comment out or remove for IPv6-only
# network6 = "fd00::/64"
# server_ip6 = "fd00::1"
#
# To allow IPv6 clients to reach IPv4 destinations, enable NAT64 (see below).

# ============================================================================
# Performance Tuning
# ============================================================================

# MTU for VPN packets (576-1500, default: 1420)
# Lower values may help with fragmentation issues
# mtu = 1420

# QUIC keepalive interval in seconds (10-300, default: 25)
# keepalive_secs = 25

# ============================================================================
# Channel Buffer Sizes
# ============================================================================
# These control packet buffering between tasks. Valid range: 1-65536.

# Per-client outbound packet buffer (default: 1024)
# Controls how many packets can be queued for each client before backpressure/drops.
# Memory impact: client_channel_size * ~1500 bytes * connected_clients
# - 1024 (default): ~1.5 MB per client worst case
# client_channel_size = 1024

# TUN writer aggregate buffer (default: 512)
# Shared buffer for all client -> TUN traffic. Lower values bound memory usage.
# Memory impact: tun_writer_channel_size * ~1500 bytes
# - 512 (default): ~750 KB worst case (safe for memory-constrained hosts)
# - 2048-4096: Better burst tolerance for high-bandwidth servers
# tun_writer_channel_size = 512

# ============================================================================
# Backpressure Behavior
# ============================================================================

# What to do when a client's send buffer is full (default: false = apply backpressure)
#
# false (default): Apply backpressure by blocking the TUN reader until the slow
#                  client's buffer has space. This guarantees no packet loss.
#                  Best for development/homelab use where reliability matters.
#
# true:            Drop packets for slow clients. Prevents one slow client from
#                  blocking packet delivery to all other clients (head-of-line
#                  blocking). Best for real-time traffic like VoIP, gaming, or
#                  interactive sessions at scale where latency matters more than
#                  guaranteed delivery.
#
# drop_on_full = false

# ============================================================================
# Server Identity (Optional)
# ============================================================================

# Path to secret key file for persistent iroh identity
# Generates same EndpointId across restarts
# Create with: tunnel-rs-vpn generate-server-key -o ./vpn-server.key
# secret_file = "./vpn-server.key"

# ============================================================================
# Authentication (REQUIRED)
# ============================================================================
# At least one authentication method is required.
# Clients must provide one of these tokens to connect.
#
# Token format: exactly 18 characters (i + 16 body chars + Luhn mod N checksum)
# Generate with: tunnel-rs-vpn generate-token

# Inline tokens (for testing; prefer auth_tokens_file in production)
# NOTE: Use either auth_tokens OR auth_tokens_file, not both.
auth_tokens = ["iXXXXXXXXXXXXXXXXX"]  # Replace with real token from generate-token

# Or use a file containing tokens (one per line, # comments allowed)
# NOTE: Use either auth_tokens OR auth_tokens_file, not both.
# auth_tokens_file = "./vpn-tokens.txt"

# ============================================================================
# Security Settings
# ============================================================================

# Disable source IP spoofing checks (default: false)
#
# When false (default): Packets are rejected if their source IP matches another
# client's assigned VPN IP (assigned client IP). This prevents inter-client
# spoofing while still allowing clients to use their own public IP addresses
# (useful for dual-stack scenarios where clients have native IPv6).
#
# When true: All source IP validation is disabled. Use with caution as this
# allows clients to send packets with arbitrary source addresses.
#
# disable_spoofing_check = false

# ============================================================================
# Relay and Discovery (Optional)
# ============================================================================

# Custom relay server URL(s) for failover
# Must match client's relay configuration for discovery
# relay_urls = [
#     "https://relay1.example.com",
#     "https://relay2.example.com",
# ]

# Custom DNS server URL for peer discovery, or "none" to disable DNS discovery.
# Must match client's dns_server configuration.
# NOTE: URL must include the /pkarr path
# dns_server = "https://dns.example.com/pkarr"
#
# Set to "none" to disable DNS-based peer discovery entirely.
# When disabled, clients and server must use one of these methods to connect:
#   1. Common relay server - both specify the same relay_urls
#   2. mDNS - automatic discovery on the same local network
# dns_server = "none"

# ============================================================================
# Transport Tuning (Optional)
# ============================================================================
# Fine-tune QUIC transport layer for performance optimization.
# All values have sensible defaults - only configure if needed.

[iroh.transport]
# Congestion controller algorithm (default: cubic)
# - cubic: Loss-based, widely deployed, best for general internet
# - bbr: Model-based, may perform better on high-bandwidth/high-latency links
# - newreno: Classic TCP-like, most conservative
# congestion_controller = "cubic"

# QUIC receive window in bytes (default: 2097152 = 2MB)
# Controls flow control - larger values allow more in-flight data
# Valid range: 1024 (1KB) to 16777216 (16MB)
# receive_window = 2097152

# QUIC send window in bytes (default: 2097152 = 2MB)
# Controls how much data can be sent before acknowledgment
# Valid range: 1024 (1KB) to 16777216 (16MB)
# send_window = 2097152

# ============================================================================
# NAT64 Configuration (Optional)
# ============================================================================
# NAT64 allows IPv6-only clients to access IPv4 resources.
# NOTE: NAT64 support is experimental.
# When enabled, the server translates IPv6 packets destined for the well-known
# NAT64 prefix (64:ff9b::/96) to IPv4 and performs NAPT.
#
# NOTE: The NAT64 prefix is fixed at 64:ff9b::/96 (RFC 6052 well-known prefix).
#
# Recommended for IPv6-only VPN configurations to maintain IPv4 compatibility.

[iroh.nat64]
# Enable NAT64 translation (default: false)
# enabled = true

# IPv4 source address for translated packets.
#
# IMPORTANT: This IP must NOT be the server's own TUN interface IP (server_ip).
# When NAT64 translates IPv6→IPv4, it uses source_ip as the source address.
# Return packets destined for source_ip must be received through the TUN interface
# for 4→6 translation to work. If source_ip equals the TUN IP, the kernel delivers
# return packets locally instead of through TUN, breaking NAT64 responses.
#
# Recommended configurations:
#
# 1. Dual-stack VPN (network + network6):
#    source_ip can be omitted; the server auto-reserves an unused IP from the
#    VPN network (not server_ip). If you prefer explicit, use an IP from the
#    VPN range that is NOT the server's IP.
#    Example: network = "10.0.0.0/24", server_ip = "10.0.0.1"
#             source_ip = "10.0.0.100"  # Different from server_ip
#
# 2. IPv6-only VPN (network6 only):
#    Use the host's WAN IPv4 address or a routable IPv4 that reaches TUN.
#    Example: source_ip = "203.0.113.5"  # Host's WAN IPv4
#
# Dynamic default (recommended for dual-stack private networks):
# If 'network' is set and source_ip is omitted, the server automatically reserves
# an unused IPv4 from the VPN network (not server_ip) for NAT64.
#
# If your IPv4 network is too small to spare an extra address, set source_ip
# explicitly or use a larger IPv4 network.
#
# source_ip = "10.0.0.100"

# Port range for NAPT (default: 32768-65535)
# Each translated connection uses one port from this range.
# port_range = [32768, 65535]

# TCP connection timeout in seconds (default: 300)
# TCP connections without activity for this duration are removed.
# tcp_timeout_secs = 300

# UDP session timeout in seconds (default: 30)
# UDP sessions without activity for this duration are removed.
# udp_timeout_secs = 30

# ICMP session timeout in seconds (default: 30)
# ICMP sessions without activity for this duration are removed.
# icmp_timeout_secs = 30
