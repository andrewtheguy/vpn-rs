# vpn-rs server configuration example
#
# Usage: vpn-rs server -c vpn_server.toml
#        vpn-rs server --default-config
#
# CLI arguments take precedence over config file values.

# Required: validates config matches CLI command
role = "vpnserver"
mode = "iroh"

[iroh]
# ============================================================================
# VPN Network Configuration
# ============================================================================
# At least one of 'network' (IPv4) or 'network6' (IPv6) is REQUIRED.
# You can configure:
#   - IPv4-only:   Set 'network' only
#   - IPv6-only:   Set 'network6' only
#   - Dual-stack:  Set both 'network' and 'network6'

# IPv4 VPN network CIDR (optional if network6 is set)
# Clients will be assigned IPs from this network
network = "10.0.0.0/24"

# Server's VPN IP address (optional, defaults to first IP in network)
# This becomes the gateway for connected clients
# server_ip = "10.0.0.1"

# ============================================================================
# IPv6 Configuration (Optional for Dual-Stack or IPv6-only)
# ============================================================================
# Enable IPv6 alongside IPv4 (dual-stack) or as the only address family (IPv6-only).
# When both network and network6 are set, clients receive addresses from both.

# IPv6 VPN network CIDR (required for dual-stack or IPv6-only)
# Clients will be assigned IPs from this network (one /128 per client)
# network6 = "fd00::/64"

# Server's IPv6 VPN address (optional, defaults to first IP in network6)
# This becomes the IPv6 gateway for connected clients
# server_ip6 = "fd00::1"

# ============================================================================
# IPv6-only Example Configuration
# ============================================================================
# For an IPv6-only VPN server, comment out 'network' above and enable:
#
# # network = "10.0.0.0/24"  # Comment out or remove for IPv6-only
# network6 = "fd00::/64"
# server_ip6 = "fd00::1"
#
# To allow IPv6 clients to reach IPv4 destinations, use external TAYGA setup:
#   docs/TAYGA_NAT64.md

# ============================================================================
# Performance Tuning
# ============================================================================

# Linux GSO offload is automatic in protocol v2 (no config toggle).
# On startup, server logs local TUN GSO status.
# Per-client, server logs: `server_local`, `client_reported`, and `active` GSO status.

# MTU for VPN packets (576-1500, default: 1420)
# Lower values may help with fragmentation issues
# mtu = 1420

# QUIC keepalive interval in seconds (10-300, default: 25)
# keepalive_secs = 25

# ============================================================================
# Channel Buffer Sizes
# ============================================================================
# These control packet buffering between tasks. Valid range: 1-65536.

# Per-client outbound packet buffer (default: 1024)
# Controls how many packets can be queued for each client before backpressure/drops.
# Memory impact: client_channel_size * ~1500 bytes * connected_clients
# - 1024 (default): ~1.5 MB per client worst case
# client_channel_size = 1024

# TUN writer aggregate buffer (default: 512)
# Shared buffer for all client -> TUN traffic. Lower values bound memory usage.
# Memory impact: tun_writer_channel_size * ~1500 bytes
# - 512 (default): ~750 KB worst case (safe for memory-constrained hosts)
# - 2048-4096: Better burst tolerance for high-bandwidth servers
# tun_writer_channel_size = 512

# ============================================================================
# Backpressure Behavior
# ============================================================================

# What to do when a client's send buffer is full (default: false = apply backpressure)
#
# false (default): Apply backpressure by blocking the TUN reader until the slow
#                  client's buffer has space. This guarantees no packet loss.
#                  Best for development/homelab use where reliability matters.
#
# true:            Drop packets for slow clients. Prevents one slow client from
#                  blocking packet delivery to all other clients (head-of-line
#                  blocking). Best for real-time traffic like VoIP, gaming, or
#                  interactive sessions at scale where latency matters more than
#                  guaranteed delivery.
#
# drop_on_full = false

# ============================================================================
# Server Identity (Required)
# ============================================================================

# Path to secret key file for persistent iroh identity (REQUIRED)
# Generates same EndpointId across restarts
# Create with: vpn-rs generate-server-key -o ./vpn-server.key
secret_file = "./vpn-server.key"

# ============================================================================
# Authentication (REQUIRED)
# ============================================================================
# At least one authentication method is required.
# Clients must provide one of these tokens to connect.
#
# Token format: exactly 47 characters (`v` + 46 Base64URL chars, no padding)
# Generate with: vpn-rs generate-token

# Inline tokens (for testing; prefer auth_tokens_file in production)
# NOTE: Use either auth_tokens OR auth_tokens_file, not both.
auth_tokens = ["<YOUR_AUTH_TOKEN>"]  # Replace with real token from generate-token

# Or use a file containing tokens (one per line, # comments allowed)
# NOTE: Use either auth_tokens OR auth_tokens_file, not both.
# auth_tokens_file = "./vpn-tokens.txt"

# ============================================================================
# Security Settings
# ============================================================================

# Disable source IP spoofing checks (default: false)
#
# When false (default): Packets are rejected if their source IP matches another
# client's assigned VPN IP (assigned client IP). This prevents inter-client
# spoofing while still allowing clients to use their own public IP addresses
# (useful for dual-stack scenarios where clients have native IPv6).
#
# When true: All source IP validation is disabled. Use with caution as this
# allows clients to send packets with arbitrary source addresses.
#
# disable_spoofing_check = false

# ============================================================================
# Relay and Discovery (Optional)
# ============================================================================

# Custom relay server URL(s) for failover
# Must match client's relay configuration for discovery
# relay_urls = [
#     "https://relay1.example.com",
#     "https://relay2.example.com",
# ]

# Custom DNS server URL for iroh endpoint discovery (pkarr), or "none" to disable DNS discovery.
# This is NOT VPN DNS and does not affect client DNS resolution.
# Must match client's dns_server configuration.
# NOTE: URL must include the /pkarr path
# dns_server = "https://dns.example.com/pkarr"
#
# Set to "none" to disable DNS-based peer discovery entirely.
# When disabled, clients and server must use one of these methods to connect:
#   1. Common relay server - both specify the same relay_urls
#   2. mDNS - automatic discovery on the same local network
# dns_server = "none"

# ============================================================================
# Transport Tuning (Optional)
# ============================================================================
# Fine-tune QUIC transport layer for performance optimization.
# All values have sensible defaults - only configure if needed.

[iroh.transport]
# Congestion controller algorithm (default: cubic)
# - cubic: Loss-based, widely deployed, best for general internet
# - bbr: Model-based, may perform better on high-bandwidth/high-latency links
# - newreno: Classic TCP-like, most conservative
# congestion_controller = "cubic"

# QUIC receive window in bytes (default: 8388608 = 8MB)
# Controls flow control - larger values allow more in-flight data
# Valid range: 1024 (1KB) to 16777216 (16MB)
# receive_window = 8388608

# QUIC send window in bytes (default: 8388608 = 8MB)
# Controls how much data can be sent before acknowledgment
# Valid range: 1024 (1KB) to 16777216 (16MB)
# send_window = 8388608
