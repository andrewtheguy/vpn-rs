//! Signaling payload types and encoding/decoding.
//!
//! Supports signaling format:
//! - v1 (Custom/Nostr mode): ICE/QUIC with str0m + quinn

use anyhow::{anyhow, Context, Result};
use base64::engine::general_purpose::URL_SAFE_NO_PAD;
use base64::Engine;
use crc32fast::Hasher;
use serde::{Deserialize, Serialize};

/// Version 1: Custom mode (str0m ICE + quinn QUIC)
pub const MANUAL_SIGNAL_VERSION: u16 = 1;
/// Version 2: Iroh multi-source handshake protocol (with token auth)
pub const IROH_MULTI_VERSION: u16 = 2;

pub(crate) const PREFIX: &str = "TRS";
pub const LINE_WIDTH: usize = 76;

// ============================================================================
// Custom Mode (v1) - str0m ICE + quinn QUIC
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ManualOffer {
    pub version: u16,
    pub ice_ufrag: String,
    pub ice_pwd: String,
    pub candidates: Vec<String>,
    pub quic_fingerprint: String,
    /// Session ID to distinguish between different signaling sessions (for nostr mode)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub session_id: Option<String>,
    /// Requested source endpoint (e.g., "tcp://127.0.0.1:22")
    /// Required for receiver-initiated handshake in manual modes
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ManualAnswer {
    pub version: u16,
    pub ice_ufrag: String,
    pub ice_pwd: String,
    pub candidates: Vec<String>,
    /// Session ID echoed from offer (for nostr mode)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub session_id: Option<String>,
    /// QUIC server fingerprint for custom-manual mode (sender is QUIC server)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub quic_fingerprint: Option<String>,
}

/// Request from receiver to initiate a tunnel session (for nostr mode).
/// Contains receiver's ICE credentials, sent before offer to trigger session start.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ManualRequest {
    pub version: u16,
    pub ice_ufrag: String,
    pub ice_pwd: String,
    pub candidates: Vec<String>,
    /// Session ID generated by receiver to filter stale events
    pub session_id: String,
    /// Unix timestamp (seconds) when request was created
    pub timestamp: u64,
    /// Requested source endpoint (e.g., "tcp://127.0.0.1:22")
    /// If None, sender uses its default source
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
}

/// Maximum length for rejection reason to prevent excessively large messages.
pub const MAX_REJECT_REASON_LENGTH: usize = 512;

/// Rejection response from sender when it cannot accept a session (for nostr mode).
/// Sent when sender is at capacity or otherwise unable to handle the request.
/// The session_id is echoed from the original request so the receiver can match it.
///
/// # Note on encode/decode helpers
///
/// Unlike [`ManualOffer`] and [`ManualAnswer`], this struct intentionally lacks
/// `encode_reject`/`decode_reject`/`display_reject` helpers. Those helpers are
/// designed for the manual stdin/stdout signaling mode with PEM-like markers.
/// `ManualReject` is only used in Nostr mode, where it is serialized directly
/// as JSON via `serde_json` before base64 encoding for transmission.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ManualReject {
    pub version: u16,
    /// Session ID echoed from request
    pub session_id: String,
    /// Rejection reason (truncated to [`MAX_REJECT_REASON_LENGTH`] bytes)
    pub reason: String,
}

impl ManualReject {
    /// Create a new rejection with the given session ID and reason.
    /// The reason will be truncated if it exceeds [`MAX_REJECT_REASON_LENGTH`].
    pub fn new(session_id: String, reason: String) -> Self {
        const TRUNCATION_SUFFIX: &str = "...";
        let reason = if reason.len() > MAX_REJECT_REASON_LENGTH {
            // Reserve space for suffix, then truncate at a valid UTF-8 boundary
            let max_content_len = MAX_REJECT_REASON_LENGTH.saturating_sub(TRUNCATION_SUFFIX.len());
            let truncated = &reason[..reason.floor_char_boundary(max_content_len)];
            format!("{}{}", truncated, TRUNCATION_SUFFIX)
        } else {
            reason
        };
        Self {
            version: MANUAL_SIGNAL_VERSION,
            session_id,
            reason,
        }
    }
}

// ============================================================================
// Iroh Multi-Source Handshake Protocol
// ============================================================================

/// Wrapper type for authentication tokens that redacts the value in Debug output.
///
/// This prevents accidental token exposure in logs or error messages.
#[derive(Clone, Serialize, Deserialize)]
#[serde(transparent)]
pub struct AuthToken(String);

impl AuthToken {
    /// Create a new AuthToken from a string.
    pub fn new(token: impl Into<String>) -> Self {
        Self(token.into())
    }

    /// Get the token value as a string slice.
    pub fn as_str(&self) -> &str {
        &self.0
    }
}

impl std::fmt::Debug for AuthToken {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AuthToken(***)")
    }
}

impl AsRef<str> for AuthToken {
    fn as_ref(&self) -> &str {
        &self.0
    }
}

impl std::ops::Deref for AuthToken {
    type Target = str;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

/// Source request sent by receiver after iroh connection established.
/// Used in iroh multi-source mode to request a specific forwarding target.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SourceRequest {
    pub version: u16,
    /// Requested source endpoint (e.g., "tcp://127.0.0.1:22" or "udp://127.0.0.1:53")
    pub source: String,
    /// Authentication token (required for server validation)
    pub auth_token: AuthToken,
}

impl SourceRequest {
    pub fn new(source: String, auth_token: impl Into<String>) -> Self {
        Self {
            version: IROH_MULTI_VERSION,
            source,
            auth_token: AuthToken::new(auth_token),
        }
    }
}

/// Source response from sender to receiver.
/// Indicates whether the requested source was accepted.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SourceResponse {
    pub version: u16,
    /// Whether the source request was accepted
    pub accepted: bool,
    /// Reason for rejection (if rejected)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
}

impl SourceResponse {
    pub fn accepted() -> Self {
        Self {
            version: IROH_MULTI_VERSION,
            accepted: true,
            reason: None,
        }
    }

    pub fn rejected(reason: impl Into<String>) -> Self {
        Self {
            version: IROH_MULTI_VERSION,
            accepted: false,
            reason: Some(reason.into()),
        }
    }
}

// ============================================================================
// Encoding/Decoding
// ============================================================================

pub fn encode_offer(offer: &ManualOffer) -> Result<String> {
    encode_payload(offer)
}

pub fn decode_offer(payload: &str) -> Result<ManualOffer> {
    decode_payload(payload)
}

pub fn encode_answer(answer: &ManualAnswer) -> Result<String> {
    encode_payload(answer)
}

pub fn decode_answer(payload: &str) -> Result<ManualAnswer> {
    decode_payload(payload)
}

// ============================================================================
// Internal Helpers
// ============================================================================

fn encode_payload<T: Serialize>(payload: &T) -> Result<String> {
    encode_payload_v(payload, MANUAL_SIGNAL_VERSION)
}

fn encode_payload_v<T: Serialize>(payload: &T, version: u16) -> Result<String> {
    let json = serde_json::to_vec(payload).context("Failed to serialize manual payload")?;
    let checksum = crc32(&json);
    let encoded = URL_SAFE_NO_PAD.encode(&json);
    Ok(format!(
        "{}{}:{:08x}:{}",
        PREFIX, version, checksum, encoded
    ))
}

fn decode_payload<T: for<'de> Deserialize<'de>>(payload: &str) -> Result<T> {
    decode_payload_v(payload, MANUAL_SIGNAL_VERSION)
}

fn decode_payload_v<T: for<'de> Deserialize<'de>>(
    payload: &str,
    expected_version: u16,
) -> Result<T> {
    let trimmed = payload.trim();
    let mut parts = trimmed.splitn(3, ':');
    let header = parts
        .next()
        .ok_or_else(|| anyhow!("Invalid manual payload header"))?;
    let checksum_hex = parts
        .next()
        .ok_or_else(|| anyhow!("Invalid manual payload checksum"))?;
    let body = parts
        .next()
        .ok_or_else(|| anyhow!("Invalid manual payload body"))?;

    if !header.starts_with(PREFIX) {
        return Err(anyhow!("Manual payload missing prefix"));
    }

    let version = header
        .strip_prefix(PREFIX)
        .ok_or_else(|| anyhow!("Manual payload missing version"))?;
    if version != expected_version.to_string() {
        return Err(anyhow!(
            "Signaling version mismatch (expected {}, got {})",
            expected_version,
            version
        ));
    }

    let expected_crc =
        u32::from_str_radix(checksum_hex, 16).context("Invalid manual payload checksum")?;
    let decoded = URL_SAFE_NO_PAD
        .decode(body.as_bytes())
        .context("Manual payload base64 decode failed")?;

    let actual_crc = crc32(&decoded);
    if actual_crc != expected_crc {
        return Err(anyhow!(
            "Manual payload checksum mismatch (expected {:08x}, got {:08x})",
            expected_crc,
            actual_crc
        ));
    }

    let parsed: T = serde_json::from_slice(&decoded).context("Manual payload JSON parse failed")?;
    Ok(parsed)
}

fn crc32(bytes: &[u8]) -> u32 {
    let mut hasher = Hasher::new();
    hasher.update(bytes);
    hasher.finalize()
}

/// Wrap a string into lines of at most `width` characters.
///
/// # Precondition
/// The input string `s` must contain only ASCII characters (as is the case for
/// base64-encoded payloads with ASCII prefix/checksum). This function chunks by
/// bytes for efficiency, which is safe for ASCII but would split multi-byte UTF-8
/// codepoints. The function will panic if given non-ASCII input.
pub fn wrap_lines(s: &str, width: usize) -> String {
    debug_assert!(
        s.is_ascii(),
        "wrap_lines requires ASCII input; got non-ASCII characters"
    );
    s.as_bytes()
        .chunks(width)
        .map(|chunk| {
            std::str::from_utf8(chunk)
                .expect("wrap_lines: chunk is not valid UTF-8; input must be ASCII")
        })
        .collect::<Vec<_>>()
        .join("\n")
}

// ============================================================================
// Stream-based Encoding/Decoding for Iroh Multi-Source
// ============================================================================

/// Maximum size for source request/response messages (16KB)
pub const MAX_SOURCE_MESSAGE_SIZE: usize = 16 * 1024;

// ============================================================================
// Length-Prefixed JSON Helpers
// ============================================================================

/// Encode a value as length-prefixed JSON bytes.
fn encode_length_prefixed<T: Serialize>(value: &T, type_name: &str) -> Result<Vec<u8>> {
    let json =
        serde_json::to_vec(value).with_context(|| format!("Failed to serialize {}", type_name))?;
    if json.len() > MAX_SOURCE_MESSAGE_SIZE {
        anyhow::bail!("{} too large: {} bytes", type_name, json.len());
    }
    let len = (json.len() as u32).to_be_bytes();
    let mut buf = Vec::with_capacity(4 + json.len());
    buf.extend_from_slice(&len);
    buf.extend_from_slice(&json);
    Ok(buf)
}

/// Decode a length-prefixed JSON value with version validation.
fn decode_length_prefixed<T: for<'de> Deserialize<'de>>(
    data: &[u8],
    expected_version: u16,
    get_version: impl FnOnce(&T) -> u16,
    type_name: &str,
) -> Result<T> {
    if data.len() < 4 {
        anyhow::bail!("{} too short: {} bytes", type_name, data.len());
    }
    let len = u32::from_be_bytes([data[0], data[1], data[2], data[3]]) as usize;
    if len > MAX_SOURCE_MESSAGE_SIZE {
        anyhow::bail!("{} length too large: {} bytes", type_name, len);
    }
    if data.len() < 4 + len {
        anyhow::bail!(
            "{} incomplete: expected {} bytes, got {}",
            type_name,
            4 + len,
            data.len()
        );
    }
    let value: T = serde_json::from_slice(&data[4..4 + len])
        .with_context(|| format!("Invalid {} JSON", type_name))?;
    let version = get_version(&value);
    if version != expected_version {
        anyhow::bail!(
            "{} version mismatch: expected {}, got {}",
            type_name,
            expected_version,
            version
        );
    }
    Ok(value)
}

/// Encode a SourceRequest as length-prefixed JSON bytes.
pub fn encode_source_request(req: &SourceRequest) -> Result<Vec<u8>> {
    encode_length_prefixed(req, "SourceRequest")
}

/// Decode a SourceRequest from length-prefixed JSON bytes.
pub fn decode_source_request(data: &[u8]) -> Result<SourceRequest> {
    decode_length_prefixed(
        data,
        IROH_MULTI_VERSION,
        |r: &SourceRequest| r.version,
        "SourceRequest",
    )
}

/// Encode a SourceResponse as length-prefixed JSON bytes.
pub fn encode_source_response(resp: &SourceResponse) -> Result<Vec<u8>> {
    encode_length_prefixed(resp, "SourceResponse")
}

/// Decode a SourceResponse from length-prefixed JSON bytes.
pub fn decode_source_response(data: &[u8]) -> Result<SourceResponse> {
    decode_length_prefixed(
        data,
        IROH_MULTI_VERSION,
        |r: &SourceResponse| r.version,
        "SourceResponse",
    )
}

/// Read a length-prefixed message from a stream.
/// Returns the raw bytes including the length prefix.
pub async fn read_length_prefixed<R: tokio::io::AsyncReadExt + Unpin>(
    reader: &mut R,
) -> Result<Vec<u8>> {
    let mut len_buf = [0u8; 4];
    reader
        .read_exact(&mut len_buf)
        .await
        .context("Failed to read message length")?;
    let len = u32::from_be_bytes(len_buf) as usize;
    if len > MAX_SOURCE_MESSAGE_SIZE {
        anyhow::bail!("Message length too large: {} bytes", len);
    }
    let mut buf = Vec::with_capacity(4 + len);
    buf.extend_from_slice(&len_buf);
    buf.resize(4 + len, 0);
    reader
        .read_exact(&mut buf[4..])
        .await
        .context("Failed to read message body")?;
    Ok(buf)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_auth_token_debug_redacts_value() {
        let token = AuthToken::new("super_secret_token");
        let debug_output = format!("{:?}", token);
        assert_eq!(debug_output, "AuthToken(***)");
        assert!(!debug_output.contains("super_secret"));
    }

    #[test]
    fn test_auth_token_accessors() {
        let token = AuthToken::new("my_token_value_");
        assert_eq!(token.as_str(), "my_token_value_");
        assert_eq!(token.as_ref(), "my_token_value_");
        assert_eq!(&*token, "my_token_value_"); // Deref
    }

    #[test]
    fn test_auth_token_serde_roundtrip() {
        let token = AuthToken::new("test_token_12345");
        let json = serde_json::to_string(&token).unwrap();
        // Should serialize as plain string (transparent)
        assert_eq!(json, "\"test_token_12345\"");

        let parsed: AuthToken = serde_json::from_str(&json).unwrap();
        assert_eq!(parsed.as_str(), "test_token_12345");
    }

    #[test]
    fn test_source_request_debug_redacts_token() {
        let request = SourceRequest::new("tcp://127.0.0.1:22".to_string(), "secret_auth_token");
        let debug_output = format!("{:?}", request);
        assert!(debug_output.contains("AuthToken(***)"));
        assert!(!debug_output.contains("secret_auth_token"));
    }

    #[test]
    fn test_source_request_serde_roundtrip() {
        let request = SourceRequest::new("tcp://127.0.0.1:22".to_string(), "my_auth_token_123");
        let encoded = encode_source_request(&request).unwrap();
        let decoded = decode_source_request(&encoded).unwrap();
        assert_eq!(decoded.source, "tcp://127.0.0.1:22");
        assert_eq!(decoded.auth_token.as_str(), "my_auth_token_123");
    }
}
