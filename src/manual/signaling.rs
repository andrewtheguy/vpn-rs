//! Manual signaling payloads and helpers.
//!
//! Supports two signaling formats:
//! - v1 (Custom mode): ICE/QUIC with str0m + quinn
//! - v2 (Iroh manual mode): Iroh endpoint with NodeId and direct addresses

use anyhow::{anyhow, Context, Result};
use base64::engine::general_purpose::URL_SAFE_NO_PAD;
use base64::Engine;
use crc32fast::Hasher;
use serde::{Deserialize, Serialize};
use std::io::BufRead;

/// Version 1: Custom mode (str0m ICE + quinn QUIC)
pub const MANUAL_SIGNAL_VERSION: u16 = 1;
/// Version 2: Iroh manual mode
pub const IROH_SIGNAL_VERSION: u16 = 2;

const PREFIX: &str = "TRS";
const LINE_WIDTH: usize = 76;

// Custom mode markers (v1)
const OFFER_BEGIN_MARKER: &str = "-----BEGIN TUNNEL-RS MANUAL OFFER-----";
const OFFER_END_MARKER: &str = "-----END TUNNEL-RS MANUAL OFFER-----";
const ANSWER_BEGIN_MARKER: &str = "-----BEGIN TUNNEL-RS MANUAL ANSWER-----";
const ANSWER_END_MARKER: &str = "-----END TUNNEL-RS MANUAL ANSWER-----";

// Iroh mode markers (v2)
const IROH_OFFER_BEGIN_MARKER: &str = "-----BEGIN TUNNEL-RS IROH OFFER-----";
const IROH_OFFER_END_MARKER: &str = "-----END TUNNEL-RS IROH OFFER-----";
const IROH_ANSWER_BEGIN_MARKER: &str = "-----BEGIN TUNNEL-RS IROH ANSWER-----";
const IROH_ANSWER_END_MARKER: &str = "-----END TUNNEL-RS IROH ANSWER-----";

// ============================================================================
// Custom Mode (v1) - str0m ICE + quinn QUIC
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ManualOffer {
    pub version: u16,
    pub ice_ufrag: String,
    pub ice_pwd: String,
    pub candidates: Vec<String>,
    pub quic_fingerprint: String,
    /// Session ID to distinguish between different signaling sessions (for nostr mode)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub session_id: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ManualAnswer {
    pub version: u16,
    pub ice_ufrag: String,
    pub ice_pwd: String,
    pub candidates: Vec<String>,
    /// Session ID echoed from offer (for nostr mode)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub session_id: Option<String>,
}

/// Request from receiver to initiate a tunnel session (for nostr mode).
/// Contains receiver's ICE credentials, sent before offer to trigger session start.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ManualRequest {
    pub version: u16,
    pub ice_ufrag: String,
    pub ice_pwd: String,
    pub candidates: Vec<String>,
    /// Session ID generated by receiver to filter stale events
    pub session_id: String,
    /// Unix timestamp (seconds) when request was created
    pub timestamp: u64,
}

/// Maximum length for rejection reason to prevent excessively large messages.
pub const MAX_REJECT_REASON_LENGTH: usize = 512;

/// Rejection response from sender when it cannot accept a session (for nostr mode).
/// Sent when sender is at capacity or otherwise unable to handle the request.
/// The session_id is echoed from the original request so the receiver can match it.
///
/// # Note on encode/decode helpers
///
/// Unlike [`ManualOffer`] and [`ManualAnswer`], this struct intentionally lacks
/// `encode_reject`/`decode_reject`/`display_reject` helpers. Those helpers are
/// designed for the manual stdin/stdout signaling mode with PEM-like markers.
/// `ManualReject` is only used in Nostr mode, where it is serialized directly
/// as JSON via `serde_json` before base64 encoding for transmission.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ManualReject {
    pub version: u16,
    /// Session ID echoed from request
    pub session_id: String,
    /// Rejection reason (truncated to [`MAX_REJECT_REASON_LENGTH`] bytes)
    pub reason: String,
}

impl ManualReject {
    /// Create a new rejection with the given session ID and reason.
    /// The reason will be truncated if it exceeds [`MAX_REJECT_REASON_LENGTH`].
    pub fn new(session_id: String, reason: String) -> Self {
        let reason = if reason.len() > MAX_REJECT_REASON_LENGTH {
            // Truncate at a valid UTF-8 boundary
            let truncated = &reason[..reason.floor_char_boundary(MAX_REJECT_REASON_LENGTH)];
            format!("{}...", truncated)
        } else {
            reason
        };
        Self {
            version: MANUAL_SIGNAL_VERSION,
            session_id,
            reason,
        }
    }
}

// ============================================================================
// Iroh Manual Mode (v2) - Iroh endpoint
// ============================================================================

/// Iroh manual mode offer (sender -> receiver)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IrohManualOffer {
    pub version: u16,
    /// Base32-encoded NodeId (public key)
    pub node_id: String,
    /// Direct socket addresses (from STUN/local interfaces)
    pub direct_addresses: Vec<String>,
}

/// Iroh manual mode answer (receiver -> sender)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IrohManualAnswer {
    pub version: u16,
    /// Base32-encoded NodeId (public key)
    pub node_id: String,
    /// Direct socket addresses (from STUN/local interfaces)
    pub direct_addresses: Vec<String>,
}

pub fn encode_offer(offer: &ManualOffer) -> Result<String> {
    encode_payload(offer)
}

pub fn decode_offer(payload: &str) -> Result<ManualOffer> {
    decode_payload(payload)
}

pub fn encode_answer(answer: &ManualAnswer) -> Result<String> {
    encode_payload(answer)
}

pub fn decode_answer(payload: &str) -> Result<ManualAnswer> {
    decode_payload(payload)
}

pub fn display_offer(offer: &ManualOffer) -> Result<()> {
    display_payload(encode_offer(offer)?, OFFER_BEGIN_MARKER, OFFER_END_MARKER)
}

pub fn display_answer(answer: &ManualAnswer) -> Result<()> {
    display_payload(encode_answer(answer)?, ANSWER_BEGIN_MARKER, ANSWER_END_MARKER)
}

pub fn read_offer_from_stdin() -> Result<ManualOffer> {
    let payload = read_marked_payload(OFFER_BEGIN_MARKER, OFFER_END_MARKER)?;
    decode_offer(&payload)
}

pub fn read_answer_from_stdin() -> Result<ManualAnswer> {
    let payload = read_marked_payload(ANSWER_BEGIN_MARKER, ANSWER_END_MARKER)?;
    decode_answer(&payload)
}

// ============================================================================
// Iroh Manual Mode (v2) - Public API
// ============================================================================

pub fn encode_iroh_offer(offer: &IrohManualOffer) -> Result<String> {
    encode_payload_v(offer, IROH_SIGNAL_VERSION)
}

pub fn decode_iroh_offer(payload: &str) -> Result<IrohManualOffer> {
    decode_payload_v(payload, IROH_SIGNAL_VERSION)
}

pub fn encode_iroh_answer(answer: &IrohManualAnswer) -> Result<String> {
    encode_payload_v(answer, IROH_SIGNAL_VERSION)
}

pub fn decode_iroh_answer(payload: &str) -> Result<IrohManualAnswer> {
    decode_payload_v(payload, IROH_SIGNAL_VERSION)
}

pub fn display_iroh_offer(offer: &IrohManualOffer) -> Result<()> {
    display_payload(encode_iroh_offer(offer)?, IROH_OFFER_BEGIN_MARKER, IROH_OFFER_END_MARKER)
}

pub fn display_iroh_answer(answer: &IrohManualAnswer) -> Result<()> {
    display_payload(encode_iroh_answer(answer)?, IROH_ANSWER_BEGIN_MARKER, IROH_ANSWER_END_MARKER)
}

pub fn read_iroh_offer_from_stdin() -> Result<IrohManualOffer> {
    let payload = read_marked_payload(IROH_OFFER_BEGIN_MARKER, IROH_OFFER_END_MARKER)?;
    decode_iroh_offer(&payload)
}

pub fn read_iroh_answer_from_stdin() -> Result<IrohManualAnswer> {
    let payload = read_marked_payload(IROH_ANSWER_BEGIN_MARKER, IROH_ANSWER_END_MARKER)?;
    decode_iroh_answer(&payload)
}

// ============================================================================
// Internal Helpers
// ============================================================================

fn encode_payload<T: Serialize>(payload: &T) -> Result<String> {
    encode_payload_v(payload, MANUAL_SIGNAL_VERSION)
}

fn encode_payload_v<T: Serialize>(payload: &T, version: u16) -> Result<String> {
    let json = serde_json::to_vec(payload).context("Failed to serialize manual payload")?;
    let checksum = crc32(&json);
    let encoded = URL_SAFE_NO_PAD.encode(&json);
    Ok(format!("{}{}:{:08x}:{}", PREFIX, version, checksum, encoded))
}

fn decode_payload<T: for<'de> Deserialize<'de>>(payload: &str) -> Result<T> {
    decode_payload_v(payload, MANUAL_SIGNAL_VERSION)
}

fn decode_payload_v<T: for<'de> Deserialize<'de>>(payload: &str, expected_version: u16) -> Result<T> {
    let trimmed = payload.trim();
    let mut parts = trimmed.splitn(3, ':');
    let header = parts
        .next()
        .ok_or_else(|| anyhow!("Invalid manual payload header"))?;
    let checksum_hex = parts
        .next()
        .ok_or_else(|| anyhow!("Invalid manual payload checksum"))?;
    let body = parts
        .next()
        .ok_or_else(|| anyhow!("Invalid manual payload body"))?;

    if !header.starts_with(PREFIX) {
        return Err(anyhow!("Manual payload missing prefix"));
    }

    let version = header
        .strip_prefix(PREFIX)
        .ok_or_else(|| anyhow!("Manual payload missing version"))?;
    if version != expected_version.to_string() {
        return Err(anyhow!(
            "Signaling version mismatch (expected {}, got {})",
            expected_version,
            version
        ));
    }

    let expected_crc = u32::from_str_radix(checksum_hex, 16)
        .context("Invalid manual payload checksum")?;
    let decoded = URL_SAFE_NO_PAD
        .decode(body.as_bytes())
        .context("Manual payload base64 decode failed")?;

    let actual_crc = crc32(&decoded);
    if actual_crc != expected_crc {
        return Err(anyhow!(
            "Manual payload checksum mismatch (expected {:08x}, got {:08x})",
            expected_crc,
            actual_crc
        ));
    }

    let parsed: T = serde_json::from_slice(&decoded).context("Manual payload JSON parse failed")?;
    Ok(parsed)
}

fn crc32(bytes: &[u8]) -> u32 {
    let mut hasher = Hasher::new();
    hasher.update(bytes);
    hasher.finalize()
}

fn wrap_lines(s: &str, width: usize) -> String {
    s.as_bytes()
        .chunks(width)
        .map(|chunk| std::str::from_utf8(chunk).unwrap_or(""))
        .collect::<Vec<_>>()
        .join("\n")
}

fn display_payload(payload: String, begin: &str, end: &str) -> Result<()> {
    let wrapped = wrap_lines(&payload, LINE_WIDTH);
    println!();
    println!("{}", begin);
    println!("{}", wrapped);
    println!("{}", end);
    println!();
    Ok(())
}

fn read_marked_payload(begin: &str, end: &str) -> Result<String> {
    let stdin = std::io::stdin();
    let mut lines = stdin.lock().lines();
    let mut collected = Vec::new();

    loop {
        let line = lines
            .next()
            .ok_or_else(|| anyhow!("Missing BEGIN marker"))??;
        let trimmed = line.trim();
        if trimmed.is_empty() {
            continue;
        }
        if trimmed == begin {
            break;
        }
        return Err(anyhow!("Unexpected text before BEGIN marker"));
    }

    let mut found_end = false;
    for line in lines {
        let line = line?;
        let trimmed = line.trim();
        if trimmed == end {
            found_end = true;
            break;
        }
        if !trimmed.is_empty() {
            collected.push(trimmed.to_string());
        }
    }

    if !found_end {
        return Err(anyhow!("END marker not found"));
    }

    if collected.is_empty() {
        return Err(anyhow!("No payload found between markers"));
    }

    Ok(collected.join(""))
}
