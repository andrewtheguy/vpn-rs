//! Signaling payload types and encoding/decoding.
//!
//! Supports two signaling formats:
//! - v1 (Custom/Nostr mode): ICE/QUIC with str0m + quinn
//! - v2 (Iroh manual mode): Iroh endpoint with NodeId and direct addresses

use anyhow::{anyhow, Context, Result};
use base64::engine::general_purpose::URL_SAFE_NO_PAD;
use base64::Engine;
use crc32fast::Hasher;
use serde::{Deserialize, Serialize};

/// Version 1: Custom mode (str0m ICE + quinn QUIC)
pub const MANUAL_SIGNAL_VERSION: u16 = 1;
/// Version 2: Iroh manual mode
pub const IROH_SIGNAL_VERSION: u16 = 2;
/// Version 1: Iroh multi-source handshake protocol
pub const IROH_MULTI_VERSION: u16 = 1;

pub(crate) const PREFIX: &str = "TRS";
pub(crate) const LINE_WIDTH: usize = 76;

// ============================================================================
// Custom Mode (v1) - str0m ICE + quinn QUIC
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ManualOffer {
    pub version: u16,
    pub ice_ufrag: String,
    pub ice_pwd: String,
    pub candidates: Vec<String>,
    pub quic_fingerprint: String,
    /// Session ID to distinguish between different signaling sessions (for nostr mode)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub session_id: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ManualAnswer {
    pub version: u16,
    pub ice_ufrag: String,
    pub ice_pwd: String,
    pub candidates: Vec<String>,
    /// Session ID echoed from offer (for nostr mode)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub session_id: Option<String>,
}

/// Request from receiver to initiate a tunnel session (for nostr mode).
/// Contains receiver's ICE credentials, sent before offer to trigger session start.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ManualRequest {
    pub version: u16,
    pub ice_ufrag: String,
    pub ice_pwd: String,
    pub candidates: Vec<String>,
    /// Session ID generated by receiver to filter stale events
    pub session_id: String,
    /// Unix timestamp (seconds) when request was created
    pub timestamp: u64,
    /// Requested source endpoint (e.g., "tcp://127.0.0.1:22")
    /// If None, sender uses its default source
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
}

/// Maximum length for rejection reason to prevent excessively large messages.
pub const MAX_REJECT_REASON_LENGTH: usize = 512;

/// Rejection response from sender when it cannot accept a session (for nostr mode).
/// Sent when sender is at capacity or otherwise unable to handle the request.
/// The session_id is echoed from the original request so the receiver can match it.
///
/// # Note on encode/decode helpers
///
/// Unlike [`ManualOffer`] and [`ManualAnswer`], this struct intentionally lacks
/// `encode_reject`/`decode_reject`/`display_reject` helpers. Those helpers are
/// designed for the manual stdin/stdout signaling mode with PEM-like markers.
/// `ManualReject` is only used in Nostr mode, where it is serialized directly
/// as JSON via `serde_json` before base64 encoding for transmission.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ManualReject {
    pub version: u16,
    /// Session ID echoed from request
    pub session_id: String,
    /// Rejection reason (truncated to [`MAX_REJECT_REASON_LENGTH`] bytes)
    pub reason: String,
}

impl ManualReject {
    /// Create a new rejection with the given session ID and reason.
    /// The reason will be truncated if it exceeds [`MAX_REJECT_REASON_LENGTH`].
    pub fn new(session_id: String, reason: String) -> Self {
        const TRUNCATION_SUFFIX: &str = "...";
        let reason = if reason.len() > MAX_REJECT_REASON_LENGTH {
            // Reserve space for suffix, then truncate at a valid UTF-8 boundary
            let max_content_len = MAX_REJECT_REASON_LENGTH.saturating_sub(TRUNCATION_SUFFIX.len());
            let truncated = &reason[..reason.floor_char_boundary(max_content_len)];
            format!("{}{}", truncated, TRUNCATION_SUFFIX)
        } else {
            reason
        };
        Self {
            version: MANUAL_SIGNAL_VERSION,
            session_id,
            reason,
        }
    }
}

// ============================================================================
// Iroh Manual Mode (v2) - Iroh endpoint
// ============================================================================

/// Iroh manual mode offer (sender -> receiver)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IrohManualOffer {
    pub version: u16,
    /// Base32-encoded NodeId (public key)
    pub node_id: String,
    /// Direct socket addresses (from STUN/local interfaces)
    pub direct_addresses: Vec<String>,
}

/// Iroh manual mode answer (receiver -> sender)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IrohManualAnswer {
    pub version: u16,
    /// Base32-encoded NodeId (public key)
    pub node_id: String,
    /// Direct socket addresses (from STUN/local interfaces)
    pub direct_addresses: Vec<String>,
}

// ============================================================================
// Iroh Multi-Source Handshake Protocol
// ============================================================================

/// Source request sent by receiver after iroh connection established.
/// Used in iroh multi-source mode to request a specific forwarding target.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SourceRequest {
    pub version: u16,
    /// Requested source endpoint (e.g., "tcp://127.0.0.1:22" or "udp://127.0.0.1:53")
    pub source: String,
}

impl SourceRequest {
    pub fn new(source: String) -> Self {
        Self {
            version: IROH_MULTI_VERSION,
            source,
        }
    }
}

/// Source response from sender to receiver.
/// Indicates whether the requested source was accepted.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SourceResponse {
    pub version: u16,
    /// Whether the source request was accepted
    pub accepted: bool,
    /// Reason for rejection (if rejected)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
}

impl SourceResponse {
    pub fn accepted() -> Self {
        Self {
            version: IROH_MULTI_VERSION,
            accepted: true,
            reason: None,
        }
    }

    pub fn rejected(reason: impl Into<String>) -> Self {
        Self {
            version: IROH_MULTI_VERSION,
            accepted: false,
            reason: Some(reason.into()),
        }
    }
}

// ============================================================================
// Encoding/Decoding
// ============================================================================

pub fn encode_offer(offer: &ManualOffer) -> Result<String> {
    encode_payload(offer)
}

pub fn decode_offer(payload: &str) -> Result<ManualOffer> {
    decode_payload(payload)
}

pub fn encode_answer(answer: &ManualAnswer) -> Result<String> {
    encode_payload(answer)
}

pub fn decode_answer(payload: &str) -> Result<ManualAnswer> {
    decode_payload(payload)
}

pub fn encode_iroh_offer(offer: &IrohManualOffer) -> Result<String> {
    encode_payload_v(offer, IROH_SIGNAL_VERSION)
}

pub fn decode_iroh_offer(payload: &str) -> Result<IrohManualOffer> {
    decode_payload_v(payload, IROH_SIGNAL_VERSION)
}

pub fn encode_iroh_answer(answer: &IrohManualAnswer) -> Result<String> {
    encode_payload_v(answer, IROH_SIGNAL_VERSION)
}

pub fn decode_iroh_answer(payload: &str) -> Result<IrohManualAnswer> {
    decode_payload_v(payload, IROH_SIGNAL_VERSION)
}

// ============================================================================
// Internal Helpers
// ============================================================================

fn encode_payload<T: Serialize>(payload: &T) -> Result<String> {
    encode_payload_v(payload, MANUAL_SIGNAL_VERSION)
}

fn encode_payload_v<T: Serialize>(payload: &T, version: u16) -> Result<String> {
    let json = serde_json::to_vec(payload).context("Failed to serialize manual payload")?;
    let checksum = crc32(&json);
    let encoded = URL_SAFE_NO_PAD.encode(&json);
    Ok(format!("{}{}:{:08x}:{}", PREFIX, version, checksum, encoded))
}

fn decode_payload<T: for<'de> Deserialize<'de>>(payload: &str) -> Result<T> {
    decode_payload_v(payload, MANUAL_SIGNAL_VERSION)
}

fn decode_payload_v<T: for<'de> Deserialize<'de>>(
    payload: &str,
    expected_version: u16,
) -> Result<T> {
    let trimmed = payload.trim();
    let mut parts = trimmed.splitn(3, ':');
    let header = parts
        .next()
        .ok_or_else(|| anyhow!("Invalid manual payload header"))?;
    let checksum_hex = parts
        .next()
        .ok_or_else(|| anyhow!("Invalid manual payload checksum"))?;
    let body = parts
        .next()
        .ok_or_else(|| anyhow!("Invalid manual payload body"))?;

    if !header.starts_with(PREFIX) {
        return Err(anyhow!("Manual payload missing prefix"));
    }

    let version = header
        .strip_prefix(PREFIX)
        .ok_or_else(|| anyhow!("Manual payload missing version"))?;
    if version != expected_version.to_string() {
        return Err(anyhow!(
            "Signaling version mismatch (expected {}, got {})",
            expected_version,
            version
        ));
    }

    let expected_crc =
        u32::from_str_radix(checksum_hex, 16).context("Invalid manual payload checksum")?;
    let decoded = URL_SAFE_NO_PAD
        .decode(body.as_bytes())
        .context("Manual payload base64 decode failed")?;

    let actual_crc = crc32(&decoded);
    if actual_crc != expected_crc {
        return Err(anyhow!(
            "Manual payload checksum mismatch (expected {:08x}, got {:08x})",
            expected_crc,
            actual_crc
        ));
    }

    let parsed: T = serde_json::from_slice(&decoded).context("Manual payload JSON parse failed")?;
    Ok(parsed)
}

fn crc32(bytes: &[u8]) -> u32 {
    let mut hasher = Hasher::new();
    hasher.update(bytes);
    hasher.finalize()
}

/// Wrap a string into lines of at most `width` characters.
///
/// # Precondition
/// The input string `s` must contain only ASCII characters (as is the case for
/// base64-encoded payloads with ASCII prefix/checksum). This function chunks by
/// bytes for efficiency, which is safe for ASCII but would split multi-byte UTF-8
/// codepoints. The function will panic if given non-ASCII input.
pub(crate) fn wrap_lines(s: &str, width: usize) -> String {
    debug_assert!(
        s.is_ascii(),
        "wrap_lines requires ASCII input; got non-ASCII characters"
    );
    s.as_bytes()
        .chunks(width)
        .map(|chunk| {
            std::str::from_utf8(chunk)
                .expect("wrap_lines: chunk is not valid UTF-8; input must be ASCII")
        })
        .collect::<Vec<_>>()
        .join("\n")
}

// ============================================================================
// Stream-based Encoding/Decoding for Iroh Multi-Source
// ============================================================================

/// Maximum size for source request/response messages (16KB)
pub const MAX_SOURCE_MESSAGE_SIZE: usize = 16 * 1024;

/// Encode a SourceRequest as length-prefixed JSON bytes.
pub fn encode_source_request(req: &SourceRequest) -> Result<Vec<u8>> {
    let json = serde_json::to_vec(req).context("Failed to serialize SourceRequest")?;
    if json.len() > MAX_SOURCE_MESSAGE_SIZE {
        anyhow::bail!("SourceRequest too large: {} bytes", json.len());
    }
    let len = (json.len() as u32).to_be_bytes();
    let mut buf = Vec::with_capacity(4 + json.len());
    buf.extend_from_slice(&len);
    buf.extend_from_slice(&json);
    Ok(buf)
}

/// Decode a SourceRequest from length-prefixed JSON bytes.
pub fn decode_source_request(data: &[u8]) -> Result<SourceRequest> {
    if data.len() < 4 {
        anyhow::bail!("SourceRequest too short: {} bytes", data.len());
    }
    let len = u32::from_be_bytes([data[0], data[1], data[2], data[3]]) as usize;
    if len > MAX_SOURCE_MESSAGE_SIZE {
        anyhow::bail!("SourceRequest length too large: {} bytes", len);
    }
    if data.len() < 4 + len {
        anyhow::bail!(
            "SourceRequest incomplete: expected {} bytes, got {}",
            4 + len,
            data.len()
        );
    }
    let req: SourceRequest =
        serde_json::from_slice(&data[4..4 + len]).context("Invalid SourceRequest JSON")?;
    if req.version != IROH_MULTI_VERSION {
        anyhow::bail!(
            "SourceRequest version mismatch: expected {}, got {}",
            IROH_MULTI_VERSION,
            req.version
        );
    }
    Ok(req)
}

/// Encode a SourceResponse as length-prefixed JSON bytes.
pub fn encode_source_response(resp: &SourceResponse) -> Result<Vec<u8>> {
    let json = serde_json::to_vec(resp).context("Failed to serialize SourceResponse")?;
    if json.len() > MAX_SOURCE_MESSAGE_SIZE {
        anyhow::bail!("SourceResponse too large: {} bytes", json.len());
    }
    let len = (json.len() as u32).to_be_bytes();
    let mut buf = Vec::with_capacity(4 + json.len());
    buf.extend_from_slice(&len);
    buf.extend_from_slice(&json);
    Ok(buf)
}

/// Decode a SourceResponse from length-prefixed JSON bytes.
pub fn decode_source_response(data: &[u8]) -> Result<SourceResponse> {
    if data.len() < 4 {
        anyhow::bail!("SourceResponse too short: {} bytes", data.len());
    }
    let len = u32::from_be_bytes([data[0], data[1], data[2], data[3]]) as usize;
    if len > MAX_SOURCE_MESSAGE_SIZE {
        anyhow::bail!("SourceResponse length too large: {} bytes", len);
    }
    if data.len() < 4 + len {
        anyhow::bail!(
            "SourceResponse incomplete: expected {} bytes, got {}",
            4 + len,
            data.len()
        );
    }
    let resp: SourceResponse =
        serde_json::from_slice(&data[4..4 + len]).context("Invalid SourceResponse JSON")?;
    if resp.version != IROH_MULTI_VERSION {
        anyhow::bail!(
            "SourceResponse version mismatch: expected {}, got {}",
            IROH_MULTI_VERSION,
            resp.version
        );
    }
    Ok(resp)
}

/// Read a length-prefixed message from a stream.
/// Returns the raw bytes including the length prefix.
pub async fn read_length_prefixed<R: tokio::io::AsyncReadExt + Unpin>(
    reader: &mut R,
) -> Result<Vec<u8>> {
    let mut len_buf = [0u8; 4];
    reader
        .read_exact(&mut len_buf)
        .await
        .context("Failed to read message length")?;
    let len = u32::from_be_bytes(len_buf) as usize;
    if len > MAX_SOURCE_MESSAGE_SIZE {
        anyhow::bail!("Message length too large: {} bytes", len);
    }
    let mut buf = Vec::with_capacity(4 + len);
    buf.extend_from_slice(&len_buf);
    buf.resize(4 + len, 0);
    reader
        .read_exact(&mut buf[4..])
        .await
        .context("Failed to read message body")?;
    Ok(buf)
}
